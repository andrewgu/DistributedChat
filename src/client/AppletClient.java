package client;

import java.io.IOException;

import javax.swing.text.AbstractDocument;
import javax.swing.text.BadLocationException;
import javax.swing.text.Element;
import javax.swing.text.GapContent;
import javax.swing.text.html.HTMLDocument;
import javax.swing.text.html.HTMLEditorKit;
import javax.swing.text.html.StyleSheet;

import protocol.MessageData;
import protocol.MessageID;
import protocol.StatusUpdate;

@SuppressWarnings("serial")
public class AppletClient extends javax.swing.JApplet
{
	private static final int INITIAL_LOG_LENGTH = 65536;
	private static final String BODY_ID = "idbody";
	private static final String DOCUMENT_PREFIX = "<!DOCTYPE HTML><html><head><title></title></head><body id=\"" + BODY_ID + "\">";
	private static final String DOCUMENT_SUFFIX = "</body></html>";
	private static final String DOCUMENT_STYLE_SHEET = "";
	
	private HTMLDocument chatDoc;
	private Element bodyElement;
	
	/** Initializes the applet AppletClient */
	public void init()
	{
		try
		{
			java.awt.EventQueue.invokeAndWait(new Runnable() {
				public void run()
				{
					try
					{
						initDocument();
					}
					catch (BadLocationException e)
					{
						// TODO Auto-generated catch block
						e.printStackTrace();
						System.exit(1);
					}
					initComponents();
				}
			});
		}
		catch (Exception ex)
		{
			ex.printStackTrace();
		}
	}
	
	private void initDocument() throws BadLocationException
	{
		AbstractDocument.Content content = new GapContent(INITIAL_LOG_LENGTH);
		
		String roomMessage = notificationMessage("Welcome!");
		content.insertString(0, DOCUMENT_PREFIX + roomMessage + DOCUMENT_SUFFIX);
		
		StyleSheet styleSheet = new StyleSheet();
		styleSheet.addRule(DOCUMENT_STYLE_SHEET);
		
		HTMLEditorKit kit = new HTMLEditorKit();
		kit.setStyleSheet(styleSheet);
		
		chatDoc = (HTMLDocument)kit.createDefaultDocument();
		chatDoc.insertString(0, DOCUMENT_PREFIX + roomMessage + DOCUMENT_SUFFIX, null);
		
		bodyElement = chatDoc.getElement(BODY_ID);
	}

	private String notificationMessage(String roomMessage)
	{
		return roomMessage;
	}

	/**
	 * This method is called from within the init() method to initialize the
	 * form. WARNING: Do NOT modify this code. The content of this method is
	 * always regenerated by the Form Editor.
	 */
	private void initComponents()
	{

		bottomPanel = new javax.swing.JPanel();
		sendButton = new javax.swing.JButton();
		messageTextArea = new javax.swing.JTextArea();
		messageEditorPane = new javax.swing.JEditorPane();

		bottomPanel.setBorder(javax.swing.BorderFactory
				.createLineBorder(new java.awt.Color(0, 0, 0)));
		bottomPanel.setLayout(new java.awt.BorderLayout());

		sendButton.setText("Send");
		sendButton.setMaximumSize(new java.awt.Dimension(51, 51));
		sendButton.setMinimumSize(new java.awt.Dimension(51, 51));
		sendButton.setPreferredSize(new java.awt.Dimension(51, 51));
		bottomPanel.add(sendButton, java.awt.BorderLayout.LINE_END);

		messageTextArea.setColumns(20);
		messageTextArea.setRows(3);
		messageTextArea.setTabSize(4);
		messageTextArea.setMinimumSize(new java.awt.Dimension(0, 51));
		bottomPanel.add(messageTextArea, java.awt.BorderLayout.CENTER);

		getContentPane().add(bottomPanel, java.awt.BorderLayout.PAGE_END);

		messageEditorPane.setBackground(new java.awt.Color(254, 254, 254));
		messageEditorPane.setBorder(javax.swing.BorderFactory
				.createLineBorder(new java.awt.Color(0, 0, 0)));
		messageEditorPane.setEditable(false);
		messageEditorPane.setDocument(chatDoc);
		getContentPane().add(messageEditorPane, java.awt.BorderLayout.CENTER);
	}// </editor-fold>

	// Variables declaration - do not modify
	private javax.swing.JPanel bottomPanel;
	private javax.swing.JEditorPane messageEditorPane;
	private javax.swing.JTextArea messageTextArea;
	private javax.swing.JButton sendButton;
	// End of variables declaration

	@Override
	public void destroy()
	{
		super.destroy();
	}

	@Override
	public void start()
	{
		super.start();
		
		try
		{
			writeStatusMessage("Started!");
		}
		catch (IOException e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	@Override
	public void stop()
	{
		super.stop();
	}
	
	private void writeChatMessage(MessageID messageID, long timestamp, String senderAlias, String message) throws IOException
	{
		try
		{
			chatDoc.insertBeforeEnd(bodyElement, "<div class=\"message\" id=\"" + getMessageIdAttribute(messageID) + "\"><span class=\"sender\">"
					+ htmlEscape(senderAlias) + "</span><span class=\"says\">says:</span><br><span class=\"msgbody\">" + message + "</span></div>");
		}
		catch (BadLocationException e)
		{
			e.printStackTrace();
		}
	}
	
	private static String htmlEscape(String string) 
	{
	    StringBuffer sb = new StringBuffer(string.length());
	    // true if last char was blank
	    boolean lastWasBlankChar = false;
	    int len = string.length();
	    char c;

	    for (int i = 0; i < len; i++)
	        {
	        c = string.charAt(i);
	        if (c == ' ') {
	            // blank gets extra work,
	            // this solves the problem you get if you replace all
	            // blanks with &nbsp;, if you do that you loss 
	            // word breaking
	            if (lastWasBlankChar) {
	                lastWasBlankChar = false;
	                sb.append("&nbsp;");
	                }
	            else {
	                lastWasBlankChar = true;
	                sb.append(' ');
	                }
	            }
	        else {
	            lastWasBlankChar = false;
	            //
	            // HTML Special Chars
	            if (c == '"')
	                sb.append("&quot;");
	            else if (c == '&')
	                sb.append("&amp;");
	            else if (c == '<')
	                sb.append("&lt;");
	            else if (c == '>')
	                sb.append("&gt;");
	            else if (c == '\n')
	                // Handle Newline
	                sb.append("&lt;br/&gt;");
	            else {
	                int ci = 0xffff & c;
	                if (ci < 160 )
	                    // nothing special only 7 Bit
	                    sb.append(c);
	                else {
	                    // Not 7 Bit use the unicode system
	                    sb.append("&#");
	                    sb.append(new Integer(ci).toString());
	                    sb.append(';');
	                    }
	                }
	            }
	        }
	    return sb.toString();
	}

	private static String getMessageIdAttribute(MessageID messageID)
	{
		return messageID.getClient().getRoom() + "-" + messageID.getClient().getClient() + "-" + messageID.getMessageNumber();
	}

	private void writeStatusMessage(String message) throws IOException
	{
		try
		{
			chatDoc.insertBeforeEnd(bodyElement, "<div class=\"status\">" + htmlEscape(message) + "</div>");
		}
		catch (BadLocationException e)
		{
			e.printStackTrace();
		}
	}
	
	private void writeErrorMessage(String message) throws IOException
	{
		try
		{
			chatDoc.insertBeforeEnd(bodyElement, "<div class=\"error\">" + htmlEscape(message) + "</div>");
		}
		catch (BadLocationException e)
		{
			e.printStackTrace();
		}
		
	}
	
	private class ClientListener implements IClientListener
	{

		@Override
		public void onConnected()
		{
			
		}

		@Override
		public void onDropped()
		{
			
		}

		@Override
		public void onMessage(MessageData message)
		{
			
		}

		@Override
		public void onStatusUpdate(StatusUpdate status)
		{
			
		}
	}
}
